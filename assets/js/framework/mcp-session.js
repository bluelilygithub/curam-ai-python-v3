/**
 * framework/mcp-session.js - Session and Context Management for MCP Applications
 * 
 * Handles conversation history, context memory, image gallery, and
 * session state management across MCP applications.
 */

class MCPSession {
    constructor(maxHistoryEntries = 10) {
        this.conversationHistory = [];
        this.imageGallery = [];
        this.contextEntries = 0;
        this.toolsChainedCount = 0;
        this.maxHistoryEntries = maxHistoryEntries;
        this.sessionId = this.generateSessionId();
        this.startTime = new Date();
    }

    /**
     * Generate unique session ID
     * @returns {string} - Unique session identifier
     */
    generateSessionId() {
        return 'mcp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Add conversation entry to history
     * @param {string} question - User question
     * @param {string} response - AI response
     * @param {Object} metadata - Additional metadata
     */
    addToConversationHistory(question, response, metadata = {}) {
        const timestamp = new Date().toLocaleTimeString();
        
        const entry = {
            id: Date.now(),
            question: question,
            response: response,
            timestamp: timestamp,
            fullTimestamp: new Date(),
            metadata: {
                ...metadata,
                sessionId: this.sessionId
            }
        };
        
        this.conversationHistory.push(entry);
        
        // Keep only the most recent entries
        if (this.conversationHistory.length > this.maxHistoryEntries) {
            this.conversationHistory = this.conversationHistory.slice(-this.maxHistoryEntries);
        }
        
        this.contextEntries = this.conversationHistory.length;
        this.updateContextDisplay();
        this.logMCP(`Added conversation entry. Total: ${this.conversationHistory.length}`);
    }

    /**
     * Add image to gallery
     * @param {string} imageBase64 - Base64 image data
     * @param {string} prompt - Image prompt
     * @param {string} style - Image style
     * @param {boolean} isAutoGenerated - Whether auto-generated
     * @param {Object} metadata - Additional metadata
     */
    addToImageGallery(imageBase64, prompt, style, isAutoGenerated = false, metadata = {}) {
        const timestamp = new Date().toLocaleTimeString();
        
        const imageEntry = {
            id: Date.now(),
            imageBase64: imageBase64,
            prompt: prompt,
            style: style,
            timestamp: timestamp,
            fullTimestamp: new Date(),
            isAutoGenerated: isAutoGenerated,
            metadata: {
                ...metadata,
                sessionId: this.sessionId
            }
        };
        
        this.imageGallery.push(imageEntry);
        this.updateContextDisplay();
        this.logMCP(`Added image to gallery. Total: ${this.imageGallery.length}`);
        
        return imageEntry.id;
    }

    /**
     * Build context-aware prompt for API calls
     * @param {string} currentPrompt - Current user prompt
     * @param {number} maxContextEntries - Max history entries to include
     * @returns {string} - Context-enhanced prompt
     */
    buildContextForAPI(currentPrompt, maxContextEntries = 3) {
        if (this.conversationHistory.length === 0) {
            return currentPrompt;
        }
        
        const recentHistory = this.conversationHistory.slice(-maxContextEntries);
        
        let contextPrompt = "Previous conversation context:\n";
        recentHistory.forEach((entry, index) => {
            contextPrompt += `Q${index + 1}: ${entry.question}\n`;
            contextPrompt += `A${index + 1}: ${entry.response.substring(0, 150)}...\n\n`;
        });
        
        contextPrompt += `Current question: ${currentPrompt}`;
        
        this.logMCP(`Built context-aware prompt with ${recentHistory.length} previous exchanges`);
        return contextPrompt;
    }

    /**
     * Update context memory display
     * @param {string} lastQuestion - Last question asked
     * @param {string} contextDescription - Description of current context
     * @param {number} toolsChained - Number of tools chained
     */
    updateContextMemory(lastQuestion = null, contextDescription = null, toolsChained = null) {
        if (lastQuestion) {
            const lastQuestionEl = document.getElementById('lastQuestion');
            if (lastQuestionEl) {
                lastQuestionEl.textContent = lastQuestion;
            }
        }

        const contextEntriesEl = document.getElementById('contextEntries');
        if (contextEntriesEl) {
            contextEntriesEl.textContent = this.contextEntries;
        }

        if (toolsChained !== null) {
            this.toolsChainedCount = toolsChained;
        }

        const toolsChainedEl = document.getElementById('toolsChained');
        if (toolsChainedEl) {
            toolsChainedEl.textContent = this.toolsChainedCount;
        }
    }

    /**
     * Update context display elements
     */
    updateContextDisplay() {
        this.updateContextMemory();
        this.updateConversationDisplay();
        this.updateImageGalleryDisplay();
    }

    /**
     * Update conversation history display
     */
    updateConversationDisplay() {
        const historyDiv = document.getElementById('conversationHistory');
        if (!historyDiv) return;
        
        if (this.conversationHistory.length === 0) {
            historyDiv.innerHTML = `
                <div class="conversation-entry empty">
                    <em>No conversation history yet. Ask a question to start building context memory.</em>
                </div>
            `;
            return;
        }
        
        historyDiv.innerHTML = this.conversationHistory.map((entry, index) => `
            <div class="conversation-entry" data-entry-id="${entry.id}">
                <div class="conversation-question">
                    ðŸ‘¤ Q${index + 1}: ${entry.question}
                </div>
                <div class="conversation-response">
                    ðŸ¤– ${this.truncateText(entry.response, 200)}
                </div>
                <div class="conversation-timestamp">
                    ${entry.timestamp}
                </div>
            </div>
        `).join('');
    }

    /**
     * Update image gallery display
     */
    updateImageGalleryDisplay() {
        const galleryDiv = document.getElementById('imageGallery');
        const thumbnailGrid = document.getElementById('thumbnailGrid');
        
        if (!galleryDiv || !thumbnailGrid) return;
        
        if (this.imageGallery.length === 0) {
            galleryDiv.style.display = 'none';
            return;
        }
        
        galleryDiv.style.display = 'block';
        
        thumbnailGrid.innerHTML = this.imageGallery.map((image, index) => `
            <div class="thumbnail-item" onclick="MCPUIComponents.openLightbox('${image.imageBase64}', '${image.prompt.replace(/'/g, "\\'")}')">
                <div class="thumbnail-number">${index + 1}</div>
                <img src="data:image/png;base64,${image.imageBase64}" alt="Generated Image ${index + 1}" />
                <div class="thumbnail-info">
                    <div class="thumbnail-prompt" title="${image.prompt}">
                        ${this.truncateText(image.prompt, 20)}
                    </div>
                    <div class="thumbnail-timestamp">
                        ${image.style} â€¢ ${image.timestamp}
                        ${image.isAutoGenerated ? ' â€¢ ðŸ¤– Auto' : ''}
                    </div>
                </div>
            </div>
        `).join('');
    }

    /**
     * Clear all session data
     * @param {boolean} confirm - Whether to show confirmation
     */
    clearSession(confirm = true) {
        if (confirm && !window.confirm('Clear all conversation history and images? This will reset the context memory.')) {
            return false;
        }

        this.conversationHistory = [];
        this.imageGallery = [];
        this.contextEntries = 0;
        this.toolsChainedCount = 0;
        
        this.updateContextDisplay();
        this.updateContextMemory('None yet', 'Ready for intelligent chaining', 0);
        
        this.logMCP('Session cleared - context memory reset');
        return true;
    }

    /**
     * Get session summary
     * @returns {Object} - Session summary data
     */
    getSessionSummary() {
        const duration = new Date() - this.startTime;
        const durationMinutes = Math.round(duration / 60000);
        
        return {
            sessionId: this.sessionId,
            startTime: this.startTime,
            duration: `${durationMinutes} minutes`,
            conversationCount: this.conversationHistory.length,
            imageCount: this.imageGallery.length,
            toolsChained: this.toolsChainedCount,
            lastActivity: this.conversationHistory.length > 0 
                ? this.conversationHistory[this.conversationHistory.length - 1].fullTimestamp 
                : this.startTime
        };
    }

    /**
     * Export session data for external use
     * @returns {Object} - Complete session data
     */
    exportSessionData() {
        return {
            sessionInfo: this.getSessionSummary(),
            conversationHistory: this.conversationHistory,
            imageGallery: this.imageGallery,
            metadata: {
                exportedAt: new Date(),
                version: '1.0'
            }
        };
    }

    /**
     * Import session data
     * @param {Object} sessionData - Session data to import
     * @returns {boolean} - Success status
     */
    importSessionData(sessionData) {
        try {
            if (sessionData.conversationHistory) {
                this.conversationHistory = sessionData.conversationHistory;
                this.contextEntries = this.conversationHistory.length;
            }
            
            if (sessionData.imageGallery) {
                // Note: Full image data won't be imported due to truncation during export
                this.imageGallery = sessionData.imageGallery;
            }
            
            this.updateContextDisplay();
            this.logMCP('Session data imported successfully');
            return true;
        } catch (error) {
            this.logMCP(`Failed to import session data: ${error.message}`);
            return false;
        }
    }

    /**
     * Get conversation context for specific entry
     * @param {number} entryId - Entry ID
     * @returns {Object|null} - Context around that entry
     */
    getConversationContext(entryId) {
        const entryIndex = this.conversationHistory.findIndex(entry => entry.id === entryId);
        if (entryIndex === -1) return null;

        const contextWindow = 2; // 2 entries before and after
        const start = Math.max(0, entryIndex - contextWindow);
        const end = Math.min(this.conversationHistory.length, entryIndex + contextWindow + 1);
        
        return {
            targetEntry: this.conversationHistory[entryIndex],
            context: this.conversationHistory.slice(start, end),
            position: entryIndex,
            total: this.conversationHistory.length
        };
    }

    /**
     * Search conversation history
     * @param {string} query - Search query
     * @returns {Array} - Matching entries
     */
    searchConversationHistory(query) {
        const queryLower = query.toLowerCase();
        return this.conversationHistory.filter(entry => 
            entry.question.toLowerCase().includes(queryLower) ||
            entry.response.toLowerCase().includes(queryLower)
        );
    }

    /**
     * Get images by criteria
     * @param {Object} criteria - Search criteria
     * @returns {Array} - Matching images
     */
    getImagesByCriteria(criteria = {}) {
        return this.imageGallery.filter(image => {
            if (criteria.style && image.style !== criteria.style) return false;
            if (criteria.isAutoGenerated !== undefined && image.isAutoGenerated !== criteria.isAutoGenerated) return false;
            if (criteria.promptContains && !image.prompt.toLowerCase().includes(criteria.promptContains.toLowerCase())) return false;
            if (criteria.after && image.fullTimestamp < criteria.after) return false;
            if (criteria.before && image.fullTimestamp > criteria.before) return false;
            return true;
        });
    }

    /**
     * Get session statistics
     * @returns {Object} - Detailed session statistics
     */
    getSessionStatistics() {
        const summary = this.getSessionSummary();
        
        // Conversation statistics
        const avgResponseLength = this.conversationHistory.length > 0
            ? this.conversationHistory.reduce((sum, entry) => sum + entry.response.length, 0) / this.conversationHistory.length
            : 0;

        // Image statistics
        const imageStyles = this.imageGallery.reduce((acc, img) => {
            acc[img.style] = (acc[img.style] || 0) + 1;
            return acc;
        }, {});

        const autoGeneratedImages = this.imageGallery.filter(img => img.isAutoGenerated).length;

        return {
            ...summary,
            conversationStats: {
                averageResponseLength: Math.round(avgResponseLength),
                totalCharacters: this.conversationHistory.reduce((sum, entry) => 
                    sum + entry.question.length + entry.response.length, 0),
                longestResponse: this.conversationHistory.length > 0 
                    ? Math.max(...this.conversationHistory.map(entry => entry.response.length))
                    : 0
            },
            imageStats: {
                styleDistribution: imageStyles,
                autoGeneratedCount: autoGeneratedImages,
                manualGeneratedCount: this.imageGallery.length - autoGeneratedImages,
                averagePromptLength: this.imageGallery.length > 0
                    ? Math.round(this.imageGallery.reduce((sum, img) => sum + img.prompt.length, 0) / this.imageGallery.length)
                    : 0
            }
        };
    }

    /**
     * Truncate text for display
     * @param {string} text - Text to truncate
     * @param {number} maxLength - Maximum length
     * @returns {string} - Truncated text
     */
    truncateText(text, maxLength) {
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength) + '...';
    }

    /**
     * Log MCP session activity
     * @param {string} message - Log message
     */
    logMCP(message) {
        if (typeof ConfigUtils !== 'undefined' && ConfigUtils.isFeatureEnabled && ConfigUtils.isFeatureEnabled('debugMode')) {
            console.log(`ðŸ”§ MCP Session: ${message}`);
        } else {
            console.log(`ðŸ”§ MCP Session: ${message}`);
        }
    }
}

// Export for global use
if (typeof window !== 'undefined') {
    window.MCPSession = MCPSession;
}

// Also export for ES6 module usage
// export { MCPSession };