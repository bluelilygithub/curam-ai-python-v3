/**
 * framework/mcp-email.js - Email Functionality Module
 * 
 * Handles all email-related functionality including:
 * - Email form modal display and management
 * - PDF attachment generation for email
 * - Email sending via MCP email service
 * - Email validation and error handling
 */

class MCPEmail {
    constructor() {
        this.defaultSubject = 'MCP Analysis Report';
        this.defaultFrom = 'mcp-hub@example.com';
    }

    /**
     * Compose email with MCP analysis content
     */
    composeEmail(content, options = {}) {
        const {
            subject = this.defaultSubject,
            to = '',
            cc = '',
            bcc = '',
            from = this.defaultFrom,
            includeAttachments = false,
            attachments = []
        } = options;

        // Create email body
        const emailBody = this.formatEmailBody(content);
        
        // Build mailto URL
        const mailtoUrl = this.buildMailtoUrl({
            to,
            cc,
            bcc,
            subject,
            body: emailBody
        });

        return {
            mailtoUrl,
            emailBody,
            options: { subject, to, cc, bcc, from, includeAttachments, attachments }
        };
    }

    /**
     * Format content for email body
     */
    formatEmailBody(content) {
        let body = 'MCP Analysis Report\n';
        body += 'Generated on: ' + new Date().toLocaleString() + '\n\n';
        body += '---\n\n';

        if (typeof content === 'string') {
            body += content;
        } else if (typeof content === 'object') {
            body += this.formatObjectForEmail(content);
        }

        body += '\n\n---\n';
        body += 'This report was generated by the MCP Hub platform.';

        return encodeURIComponent(body);
    }

    /**
     * Format object content for email
     */
    formatObjectForEmail(obj) {
        let formatted = '';

        if (obj.question) {
            formatted += `Question: ${obj.question}\n\n`;
        }

        if (obj.analysis) {
            formatted += `Analysis:\n${obj.analysis}\n\n`;
        }

        if (obj.recommendation) {
            formatted += `Recommendation:\n${obj.recommendation}\n\n`;
        }

        if (obj.options && Array.isArray(obj.options)) {
            formatted += 'Options:\n';
            obj.options.forEach((option, index) => {
                formatted += `${index + 1}. ${option.title || option.name}\n`;
                if (option.score) formatted += `   Score: ${option.score}\n`;
                if (option.pros) formatted += `   Pros: ${option.pros}\n`;
                if (option.cons) formatted += `   Cons: ${option.cons}\n`;
                formatted += '\n';
            });
        }

        if (obj.conclusion) {
            formatted += `Conclusion:\n${obj.conclusion}\n\n`;
        }

        return formatted;
    }

    /**
     * Build mailto URL
     */
    buildMailtoUrl(params) {
        const { to, cc, bcc, subject, body } = params;
        let url = 'mailto:';

        if (to) url += encodeURIComponent(to);
        if (cc) url += `?cc=${encodeURIComponent(cc)}`;
        if (bcc) url += `${url.includes('?') ? '&' : '?'}bcc=${encodeURIComponent(bcc)}`;
        if (subject) url += `${url.includes('?') ? '&' : '?'}subject=${encodeURIComponent(subject)}`;
        if (body) url += `${url.includes('?') ? '&' : '?'}body=${body}`;

        return url;
    }

    /**
     * Send email using mailto
     */
    sendEmail(content, options = {}) {
        const emailData = this.composeEmail(content, options);
        
        // Open default email client
        window.open(emailData.mailtoUrl, '_blank');
        
        return emailData;
    }

    /**
     * Generate email from conversation
     */
    generateConversationEmail(conversation, options = {}) {
        const content = this.formatConversationForEmail(conversation);
        return this.composeEmail(content, {
            subject: 'MCP Conversation Summary',
            ...options
        });
    }

    /**
     * Format conversation for email
     */
    formatConversationForEmail(conversation) {
        let content = 'MCP Conversation Summary\n\n';
        
        conversation.forEach((message, index) => {
            const role = message.role || 'user';
            const messageContent = message.content || '';
            
            content += `${role.toUpperCase()}:\n`;
            content += `${messageContent}\n\n`;
        });

        return content;
    }

    /**
     * Generate email from decision analysis
     */
    generateDecisionEmail(decisionData, options = {}) {
        const content = this.formatDecisionForEmail(decisionData);
        return this.composeEmail(content, {
            subject: 'MCP Decision Analysis Report',
            ...options
        });
    }

    /**
     * Format decision data for email
     */
    formatDecisionForEmail(decisionData) {
        let content = 'MCP Decision Analysis Report\n\n';

        if (decisionData.question) {
            content += `Question: ${decisionData.question}\n\n`;
        }

        if (decisionData.options && decisionData.options.length > 0) {
            content += 'Options Analysis:\n';
            decisionData.options.forEach((option, index) => {
                content += `${index + 1}. ${option.title || option.name}\n`;
                if (option.score) content += `   Score: ${option.score}\n`;
                if (option.pros) content += `   Pros: ${option.pros}\n`;
                if (option.cons) content += `   Cons: ${option.cons}\n\n`;
            });
        }

        if (decisionData.recommendation) {
            content += `Recommendation:\n${decisionData.recommendation}\n\n`;
        }

        if (decisionData.conclusion) {
            content += `Conclusion:\n${decisionData.conclusion}\n\n`;
        }

        return content;
    }

    /**
     * Create email template
     */
    createEmailTemplate(templateName, data = {}) {
        const templates = {
            'analysis-report': {
                subject: 'MCP Analysis Report',
                body: `Dear ${data.recipient || 'Team'},

Please find below the MCP analysis report for your review.

Question: ${data.question || 'N/A'}

Analysis:
${data.analysis || 'N/A'}

Recommendation:
${data.recommendation || 'N/A'}

Best regards,
MCP Hub Team`
            },
            'decision-summary': {
                subject: 'MCP Decision Summary',
                body: `Dear ${data.recipient || 'Team'},

Please find below the decision analysis summary.

Decision Question: ${data.question || 'N/A'}

Selected Option: ${data.selectedOption || 'N/A'}

Rationale: ${data.rationale || 'N/A'}

Best regards,
MCP Hub Team`
            }
        };

        return templates[templateName] || templates['analysis-report'];
    }

    /**
     * Main email report function
     * @param {Object} session - MCP session object with conversation history and images
     * @param {Object} options - Email options
     * @returns {Promise} - Email sending promise
     */
    static async emailReport(session, options = {}) {
        if (!session || (session.conversationHistory.length === 0 && session.imageGallery.length === 0)) {
            throw new Error('No conversation history or images to email!');
        }

        const defaultOptions = {
            prefilledTo: '',
            prefilledSubject: 'MCP Session Report - Curam AI Demo',
            includeAttachment: true,
            apiBaseUrl: null // Will use ConfigUtils if available
        };
        
        const config = { ...defaultOptions, ...options };

        // Pre-fill email message with session summary
        const sessionSummary = `${session.conversationHistory.length} questions and ${session.imageGallery.length} generated images`;
        
        // Show email modal and return promise
        return new Promise((resolve, reject) => {
            this.showEmailModal(session, sessionSummary, config, resolve, reject);
        });
    }

    /**
     * Show email modal with form
     * @param {Object} session - Session object
     * @param {string} sessionSummary - Summary of the session
     * @param {Object} config - Email configuration
     * @param {Function} resolve - Promise resolve function
     * @param {Function} reject - Promise reject function
     */
    static showEmailModal(session, sessionSummary, config, resolve, reject) {
        // Remove existing modal
        const existingModal = document.getElementById('mcpEmailModal');
        if (existingModal) {
            existingModal.remove();
        }

        // Create email modal
        const emailModal = document.createElement('div');
        emailModal.id = 'mcpEmailModal';
        emailModal.className = 'email-modal active';
        emailModal.innerHTML = this.getEmailModalHTML(sessionSummary, config);

        document.body.appendChild(emailModal);

        // Set up form submission
        const emailForm = document.getElementById('mcpEmailForm');
        emailForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            try {
                const result = await this.sendEmailWithPDF(session, config);
                this.closeEmailModal();
                resolve(result);
            } catch (error) {
                reject(error);
            }
        });

        // Set up cancel button
        const cancelBtn = document.getElementById('mcpEmailCancel');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                this.closeEmailModal();
                reject(new Error('Email cancelled by user'));
            });
        }

        // Close on background click
        emailModal.onclick = (e) => {
            if (e.target === emailModal) {
                this.closeEmailModal();
                reject(new Error('Email cancelled by user'));
            }
        };

        // Close on escape key
        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                this.closeEmailModal();
                document.removeEventListener('keydown', escapeHandler);
                reject(new Error('Email cancelled by user'));
            }
        };
        document.addEventListener('keydown', escapeHandler);
    }

    /**
     * Get email modal HTML
     * @param {string} sessionSummary - Session summary text
     * @param {Object} config - Email configuration
     * @returns {string} - Modal HTML
     */
    static getEmailModalHTML(sessionSummary, config) {
        const defaultMessage = `Hi,

Please find attached the MCP (Model Context Protocol) session report from our Curam AI demonstration.

This report showcases:
- Intelligent tool orchestration and context memory
- Auto-generated images based on conversation context  
- Real-time workflow visualization
- Context-aware AI responses

The session included ${sessionSummary} demonstrating the advanced capabilities of our MCP implementation.

Best regards`;

        return `
            <div class="email-modal-content">
                <button class="close-modal" onclick="window.MCPEmail.closeEmailModal()">&times;</button>
                <h3>ðŸ“§ Email MCP Session Report</h3>
                
                <div class="email-info">
                    <strong>Real Email Delivery:</strong> This will generate a PDF and send it directly via our MCP email service. 
                    The recipient will receive an actual email with the report attached.
                </div>
                
                <form class="email-form" id="mcpEmailForm">
                    <div>
                        <label for="mcpEmailTo">To (Email Address):</label>
                        <input type="email" id="mcpEmailTo" placeholder="boss@company.com" value="${config.prefilledTo}" required>
                    </div>
                    
                    <div>
                        <label for="mcpEmailSubject">Subject:</label>
                        <input type="text" id="mcpEmailSubject" value="${config.prefilledSubject}" required>
                    </div>
                    
                    <div>
                        <label for="mcpEmailMessage">Message:</label>
                        <textarea id="mcpEmailMessage" rows="8" placeholder="Please find attached the MCP session report...">${defaultMessage}</textarea>
                    </div>
                    
                    ${config.includeAttachment ? `
                        <div>
                            <label class="checkbox-label">
                                <input type="checkbox" id="mcpEmailAttachment" checked>
                                <span>ðŸ“Ž Include PDF attachment</span>
                            </label>
                            <small class="checkbox-help">
                                Uncheck if you only want to send the message without PDF attachment
                            </small>
                        </div>
                    ` : ''}
                    
                    <div class="email-buttons">
                        <button type="button" class="btn" id="mcpEmailCancel" style="background: #999;">
                            Cancel
                        </button>
                        <button type="submit" class="btn" style="background: #0073aa;">
                            ðŸ“§ Send Email
                        </button>
                    </div>
                </form>
            </div>
        `;
    }

    /**
     * Close email modal
     */
    static closeEmailModal() {
        const modal = document.getElementById('mcpEmailModal');
        if (modal) {
            modal.remove();
        }
    }

    /**
     * Send email with PDF attachment
     * @param {Object} session - Session object
     * @param {Object} config - Email configuration
     * @returns {Promise} - Email sending result
     */
    static async sendEmailWithPDF(session, config) {
        const emailTo = document.getElementById('mcpEmailTo').value.trim();
        const emailSubject = document.getElementById('mcpEmailSubject').value.trim();
        const emailMessage = document.getElementById('mcpEmailMessage').value.trim();
        const includeAttachment = document.getElementById('mcpEmailAttachment') ? 
            document.getElementById('mcpEmailAttachment').checked : config.includeAttachment;

        // Validate input
        const validation = this.validateEmailInput(emailTo, emailSubject, emailMessage);
        if (!validation.valid) {
            throw new Error(validation.error);
        }

        // Show loading state
        const sendBtn = document.querySelector('#mcpEmailForm button[type="submit"]');
        const originalText = sendBtn.textContent;
        sendBtn.textContent = 'ðŸ“§ Sending Email...';
        sendBtn.disabled = true;

        try {
            let pdfBase64 = null;
            let pdfTooLarge = false;
            // Always generate a text-only PDF for email (no images, but with note)
            if (includeAttachment) {
                pdfBase64 = await window.MCPPDFExport.generatePDFWithoutImages(session, { noteForEmail: false });
                if (pdfBase64) {
                    const pdfSizeKB = Math.round((pdfBase64.length * 3/4) / 1024);
                    console.log(`ðŸ”§ MCP Email: PDF size: ${pdfSizeKB}KB (no images)`);
                }
            }
            // If PDF is too large, add a note to the message
            let emailMessageFinal = emailMessage;
            if (pdfTooLarge) {
                emailMessageFinal += '\n\n[Note: The PDF report was not attached because it exceeded the size limit. Please use the Export PDF feature in the app to download it manually.]';
            }
            // Build final payload
            const finalPayload = {
                to: emailTo,
                subject: emailSubject,
                message: emailMessageFinal
            };
            if (pdfBase64) finalPayload.pdf_base64 = pdfBase64;
            // Final size check
            const finalPayloadString = JSON.stringify(finalPayload);
            const payloadSizeKB = Math.round((finalPayloadString.length * 2) / 1024);
            if (payloadSizeKB > 5000) {
                alert('The email payload is still too large to send (over 5MB). Please reduce the number of images or use lower resolution. The email will NOT be sent.');
                throw new Error('EMAIL_PAYLOAD_TOO_LARGE');
            }
            // Send email via API
            const result = await this.sendEmailViaAPI(emailTo, emailSubject, emailMessageFinal, pdfBase64, config);
            console.log('ðŸ”§ MCP Email: Email sent successfully');
            return {
                success: true,
                to: emailTo,
                subject: emailSubject,
                attachmentIncluded: !!pdfBase64,
                result: result
            };
        } catch (error) {
            console.error('ðŸ”§ MCP Email: Sending failed:', error);
            throw this.enhanceEmailError(error);
        } finally {
            sendBtn.textContent = originalText;
            sendBtn.disabled = false;
        }
    }

    /**
     * Generate optimized PDF for email attachment
     * @param {Object} session - Session object
     * @returns {Promise<string|null>} - Base64 PDF data or null
     */
    static async generateOptimizedPDFForEmail(session) {
        if (typeof window.jspdf === 'undefined') {
            console.warn('ðŸ”§ MCP Email: jsPDF not available - sending email without attachment');
            return null;
        }

        try {
            console.log('ðŸ”§ MCP Email: Generating optimized PDF for email attachment');
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            
            // Use the PDF export module if available, otherwise generate inline
            if (typeof window.MCPPDFExport !== 'undefined') {
                await window.MCPPDFExport.generatePDFForEmail(session, pdf, { maxImages: 0 });
            } else {
                // Fallback: generate simple PDF inline
                await this.generateSimplePDFForEmail(session, pdf);
            }
            
            // Get base64 without data URI prefix
            const pdfDataUri = pdf.output('datauristring');
            const pdfBase64 = pdfDataUri.split(',')[1]; // Remove "data:application/pdf;base64," prefix
            
            console.log('ðŸ”§ MCP Email: PDF generated successfully for email');
            return pdfBase64;
            
        } catch (error) {
            console.error('ðŸ”§ MCP Email: PDF generation failed:', error);
            return null; // Continue without attachment
        }
    }

    /**
     * Generate simple PDF for email (fallback when MCPPDFExport not available)
     * @param {Object} session - Session object
     * @param {jsPDF} pdf - PDF instance
     */
    static async generateSimplePDFForEmail(session, pdf) {
        const pageWidth = pdf.internal.pageSize.getWidth();
        let yPosition = 20;
        
        // Set default font
        pdf.setFont('helvetica');
        
        // Header
        pdf.setFontSize(18);
        pdf.setTextColor(0, 115, 170);
        pdf.text('Curam AI MCP Session Report', pageWidth / 2, yPosition, { align: 'center' });
        
        yPosition += 15;
        pdf.setFontSize(10);
        pdf.setTextColor(102, 102, 102);
        pdf.text('Generated on ' + new Date().toLocaleString(), pageWidth / 2, yPosition, { align: 'center' });
        
        yPosition += 20;
        
        // Summary
        pdf.setFontSize(12);
        pdf.setTextColor(0, 115, 170);
        pdf.text('Session Summary', 20, yPosition);
        
        yPosition += 10;
        pdf.setFontSize(10);
        pdf.setTextColor(51, 51, 51);
        pdf.text('Total Questions: ' + session.conversationHistory.length, 20, yPosition);
        yPosition += 6;
        pdf.text('Images Generated: ' + session.imageGallery.length, 20, yPosition);
        yPosition += 6;
        pdf.text('MCP Features: Context Memory, Tool Chaining', 20, yPosition);
        
        yPosition += 15;
        
        // Key conversations (limited)
        if (session.conversationHistory.length > 0) {
            pdf.setFontSize(12);
            pdf.setTextColor(0, 115, 170);
            pdf.text('Key Conversation Points', 20, yPosition);
            yPosition += 10;
            
            const maxConversations = Math.min(2, session.conversationHistory.length);
            for (let i = 0; i < maxConversations; i++) {
                const entry = session.conversationHistory[i];
                
                pdf.setFontSize(10);
                pdf.setTextColor(0, 115, 170);
                const cleanQuestion = this.cleanTextForPDF(entry.question);
                pdf.text('Q' + (i + 1) + ': ' + cleanQuestion, 20, yPosition);
                yPosition += 8;
                
                pdf.setFontSize(9);
                pdf.setTextColor(51, 51, 51);
                const cleanResponse = this.cleanTextForPDF(entry.response.substring(0, 100)) + '...';
                const splitText = pdf.splitTextToSize(cleanResponse, pageWidth - 40);
                pdf.text(splitText, 25, yPosition);
                yPosition += splitText.length * 4 + 10;
            }
        }
        
        // Note about full report
        yPosition += 10;
        pdf.setFontSize(9);
        pdf.setTextColor(102, 102, 102);
        pdf.text('This is a summary email version. Full report with images available via Export PDF.', 20, yPosition);
    }

    /**
     * Send email via API
     * @param {string} to - Recipient email
     * @param {string} subject - Email subject
     * @param {string} message - Email message
     * @param {string|null} pdfBase64 - PDF attachment data
     * @param {Object} config - Email configuration
     * @param {Array} attachments - Additional attachments for the email
     * @returns {Promise} - API response
     */
    static async sendEmailViaAPI(to, subject, message, pdfBase64, config, attachments = []) {
        // Determine API base URL
        const apiBaseUrl = config.apiBaseUrl || 
            (typeof ConfigUtils !== 'undefined' ? ConfigUtils.getApiUrl('').replace(/\/$/, '') : 
             'https://curam-ai-agent-mcp-production.up.railway.app');

        console.log('ðŸ”§ MCP Email: Sending email via MCP email service');
        
        const payload = {
            to: to,
            subject: subject,
            message: message,
            attachments: attachments
        };
        if (pdfBase64) {
            payload.pdf_base64 = pdfBase64;
        }
        // Log payload size and presence of pdf_base64
        const payloadString = JSON.stringify(payload);
        const payloadSizeKB = Math.round((payloadString.length * 2) / 1024); // JS strings are 2 bytes per char
        console.log(`ðŸ”§ MCP Email: Payload size: ${payloadSizeKB}KB, pdf_base64 present: ${!!pdfBase64}`);
        if (payloadSizeKB > 5000) {
            alert('The email payload is still too large to send (over 5MB). Please reduce the number of images or use lower resolution. The email will NOT be sent.');
            throw new Error('EMAIL_PAYLOAD_TOO_LARGE');
        }
        const response = await fetch(`${apiBaseUrl}/api/send-email`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: payloadString
        });

        // Handle different response types
        let result;
        const contentType = response.headers.get('content-type');
        
        if (contentType && contentType.includes('application/json')) {
            result = await response.json();
        } else {
            // Handle HTML error responses (like 413 errors)
            const textResponse = await response.text();
            console.error('ðŸ”§ MCP Email: Received HTML response:', textResponse.substring(0, 200));
            
            if (response.status === 413) {
                throw new Error('PDF_TOO_LARGE');
            } else {
                throw new Error(`SERVER_ERROR_${response.status}`);
            }
        }

        if (!response.ok) {
            throw new Error(result.error || result.message || `HTTP_${response.status}`);
        }

        if (result.status !== 'sent') {
            throw new Error(result.error || result.message || 'EMAIL_SEND_FAILED');
        }

        return result;
    }

    /**
     * Validate email input
     * @param {string} email - Email address
     * @param {string} subject - Email subject
     * @param {string} message - Email message
     * @returns {Object} - Validation result
     */
    static validateEmailInput(email, subject, message) {
        if (!email || !email.trim()) {
            return { valid: false, error: 'Email address is required' };
        }

        if (!this.isValidEmail(email)) {
            return { valid: false, error: 'Please enter a valid email address' };
        }

        if (!subject || !subject.trim()) {
            return { valid: false, error: 'Email subject is required' };
        }

        if (subject.length > 200) {
            return { valid: false, error: 'Email subject is too long (max 200 characters)' };
        }

        if (!message || !message.trim()) {
            return { valid: false, error: 'Email message is required' };
        }

        if (message.length > 5000) {
            return { valid: false, error: 'Email message is too long (max 5000 characters)' };
        }

        return { valid: true };
    }

    /**
     * Check if email address is valid
     * @param {string} email - Email to validate
     * @returns {boolean} - Whether email is valid
     */
    static isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    /**
     * Enhance error messages for better user experience
     * @param {Error} error - Original error
     * @returns {Error} - Enhanced error
     */
    static enhanceEmailError(error) {
        const message = error.message || '';
        
        if (message.includes('PDF_TOO_LARGE') || message.includes('413')) {
            return new Error('PDF attachment too large for email service. Try using "Export PDF" instead to download and manually attach.');
        } else if (message.includes('network') || message.includes('fetch')) {
            return new Error('Network connection issue. Please check your internet connection and try again.');
        } else if (message.includes('MAILCHANNELS_API_KEY')) {
            return new Error('Email service configuration issue. Please contact support.');
        } else if (message.includes('SERVER_ERROR')) {
            return new Error('Server error occurred. Please try again later or use "Export PDF" as an alternative.');
        } else if (message.includes('EMAIL_SEND_FAILED')) {
            return new Error('Email could not be sent. Please verify the recipient address and try again.');
        } else {
            return new Error(`Email sending failed: ${message}`);
        }
    }

    /**
     * Clean text for PDF generation (simple version for email module)
     * @param {string} text - Text to clean
     * @returns {string} - Cleaned text
     */
    static cleanTextForPDF(text) {
        if (!text || typeof text !== 'string') return '';
        
        return text
            .replace(/[^\x00-\x7F]/g, '') // Remove non-ASCII characters
            .replace(/[""]/g, '"') // Replace smart quotes
            .replace(/['']/g, "'") // Replace smart apostrophes
            .replace(/[â€“â€”]/g, '-') // Replace em/en dashes
            .replace(/\s+/g, ' ') // Normalize whitespace
            .trim();
    }

    /**
     * Get email statistics and information
     * @param {Object} session - Session object
     * @returns {Object} - Email statistics
     */
    static getEmailStats(session) {
        if (!session) {
            return { valid: false, error: 'No session provided' };
        }

        const stats = {
            valid: true,
            hasContent: session.conversationHistory.length > 0 || session.imageGallery.length > 0,
            conversations: session.conversationHistory.length,
            images: session.imageGallery.length,
            estimatedPDFSize: this.estimatePDFSize(session),
            canSendEmail: true,
            warnings: []
        };

        // Check for potential issues
        if (stats.estimatedPDFSize > 5000) {
            stats.warnings.push('PDF attachment may be too large for some email services');
        }

        if (session.imageGallery.length > 5) {
            stats.warnings.push('Many images may increase PDF generation time');
        }

        if (!stats.hasContent) {
            stats.canSendEmail = false;
            stats.warnings.push('No content available to email');
        }

        return stats;
    }

    /**
     * Estimate PDF file size for email planning
     * @param {Object} session - Session object
     * @returns {number} - Estimated size in KB
     */
    static estimatePDFSize(session) {
        const baseSize = 50; // KB for text content
        const imageSize = Math.min(session.imageGallery.length, 3) * 80; // ~80KB per image (compressed for email)
        return baseSize + imageSize;
    }

    /**
     * Create email preview without sending
     * @param {Object} session - Session object
     * @param {Object} emailData - Email form data
     * @returns {Object} - Email preview data
     */
    static createEmailPreview(session, emailData) {
        const stats = this.getEmailStats(session);
        
        return {
            ...stats,
            to: emailData.to,
            subject: emailData.subject,
            messageLength: emailData.message.length,
            hasAttachment: emailData.includeAttachment && stats.hasContent,
            preview: {
                conversations: Math.min(session.conversationHistory.length, 3),
                images: Math.min(session.imageGallery.length, 3),
                truncated: {
                    conversations: session.conversationHistory.length > 3,
                    images: session.imageGallery.length > 3
                }
            }
        };
    }

    /**
     * Test email configuration
     * @param {Object} config - Email configuration to test
     * @returns {Promise<Object>} - Test result
     */
    static async testEmailConfig(config = {}) {
        try {
            const apiBaseUrl = config.apiBaseUrl || 
                (typeof ConfigUtils !== 'undefined' ? ConfigUtils.getApiUrl('').replace(/\/$/, '') : 
                 'https://curam-ai-agent-mcp-production.up.railway.app');

            const response = await fetch(`${apiBaseUrl}/health`, {
                method: 'GET',
                timeout: 5000
            });

            if (response.ok) {
                return { 
                    success: true, 
                    message: 'Email service is available',
                    apiUrl: apiBaseUrl
                };
            } else {
                return { 
                    success: false, 
                    error: `Service responded with status ${response.status}`,
                    apiUrl: apiBaseUrl
                };
            }
        } catch (error) {
            return { 
                success: false, 
                error: `Connection failed: ${error.message}`,
                apiUrl: config.apiBaseUrl || 'default'
            };
        }
    }
}

// Export for global use
if (typeof window !== 'undefined') {
    window.MCPEmail = MCPEmail;
}

// Also export for ES6 module usage
// export { MCPEmail };